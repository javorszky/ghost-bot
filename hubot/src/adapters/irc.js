// Generated by CoffeeScript 1.4.0
(function() {
  var Adapter, EnterMessage, Irc, IrcBot, LeaveMessage, Response, Robot, TextMessage, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  _ref = require('../../index'), Robot = _ref.Robot, Adapter = _ref.Adapter, TextMessage = _ref.TextMessage, EnterMessage = _ref.EnterMessage, LeaveMessage = _ref.LeaveMessage, Response = _ref.Response;

  Irc = require('irc');

  IrcBot = (function(_super) {

    __extends(IrcBot, _super);

    function IrcBot() {
      return IrcBot.__super__.constructor.apply(this, arguments);
    }

    IrcBot.prototype.send = function() {
      var envelope, str, strings, target, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (process.env.HUBOT_IRC_SEND_NOTICE_MODE != null) {
        return this.notice(envelope, strings);
      }
      target = this._getTargetFromEnvelope(envelope);
      if (!target) {
        return console.log("ERROR: Not sure who to send to. envelope=", envelope);
      }
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.bot.say(target, str));
      }
      return _results;
    };

    IrcBot.prototype.notice = function() {
      var envelope, flattened, str, strings, target, _i, _j, _len, _len1, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      target = this._getTargetFromEnvelope(envelope);
      if (!target) {
        return console.log("Notice: no target found", envelope);
      }
      flattened = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        if (Array.isArray(str)) {
          flattened = flattened.concat(str);
        } else {
          flattened.push(str);
        }
      }
      _results = [];
      for (_j = 0, _len1 = flattened.length; _j < _len1; _j++) {
        str = flattened[_j];
        if (!(str != null)) {
          continue;
        }
        _results.push(this.bot.notice(target, str));
      }
      return _results;
    };

    IrcBot.prototype.reply = function() {
      var envelope, str, strings, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.send(envelope.user, "" + envelope.user.name + ": " + str));
      }
      return _results;
    };

    IrcBot.prototype.join = function(channel) {
      var self;
      self = this;
      return this.bot.join(channel, function() {
        console.log('joined %s', channel);
        return self.receive(new EnterMessage(null));
      });
    };

    IrcBot.prototype.part = function(channel) {
      var self;
      self = this;
      return this.bot.part(channel, function() {
        console.log('left %s', channel);
        return self.receive(new LeaveMessage(null));
      });
    };

    IrcBot.prototype.createUser = function(channel, from) {
      var id, user;
      user = this.userForName(from);
      if (user == null) {
        id = new Date().getTime().toString();
        user = this.userForId(id);
        user.name = from;
      }
      if (channel.match(/^[&#]/)) {
        user.room = channel;
      } else {
        user.room = null;
      }
      return user;
    };

    IrcBot.prototype.kick = function(channel, client, message) {
      return this.bot.emit('raw', {
        command: 'KICK',
        nick: process.env.HUBOT_IRC_NICK,
        args: [channel, client, message]
      });
    };

    IrcBot.prototype.command = function() {
      var command, strings, _ref1;
      command = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return (_ref1 = this.bot).send.apply(_ref1, [command].concat(__slice.call(strings)));
    };

    IrcBot.prototype.checkCanStart = function() {
      if (!process.env.HUBOT_IRC_NICK && !this.robot.name) {
        throw new Error("HUBOT_IRC_NICK is not defined; try: export HUBOT_IRC_NICK='mybot'");
      } else if (!process.env.HUBOT_IRC_ROOMS) {
        throw new Error("HUBOT_IRC_ROOMS is not defined; try: export HUBOT_IRC_ROOMS='#myroom'");
      } else if (!process.env.HUBOT_IRC_SERVER) {
        throw new Error("HUBOT_IRC_SERVER is not defined: try: export HUBOT_IRC_SERVER='irc.myserver.com'");
      }
    };

    IrcBot.prototype.run = function() {
      var bot, client_options, identify_args, next_id, options, self, user_id;
      self = this;
      this.checkCanStart();
      options = {
        nick: process.env.HUBOT_IRC_NICK || this.robot.name,
        realName: process.env.HUBOT_IRC_REALNAME,
        port: process.env.HUBOT_IRC_PORT,
        rooms: process.env.HUBOT_IRC_ROOMS.split(","),
        server: process.env.HUBOT_IRC_SERVER,
        password: process.env.HUBOT_IRC_PASSWORD,
        nickpass: process.env.HUBOT_IRC_NICKSERV_PASSWORD,
        nickusername: process.env.HUBOT_IRC_NICKSERV_USERNAME,
        connectCommand: process.env.HUBOT_IRC_CONNECT_COMMAND,
        fakessl: process.env.HUBOT_IRC_SERVER_FAKE_SSL != null,
        certExpired: process.env.HUBOT_IRC_SERVER_CERT_EXPIRED != null,
        unflood: process.env.HUBOT_IRC_UNFLOOD != null,
        debug: process.env.HUBOT_IRC_DEBUG != null,
        usessl: process.env.HUBOT_IRC_USESSL != null,
        userName: process.env.HUBOT_IRC_USERNAME
      };
      client_options = {
        userName: options.userName,
        realName: options.realName,
        password: options.password,
        debug: options.debug,
        port: options.port,
        stripColors: true,
        secure: options.usessl,
        selfSigned: options.fakessl,
        certExpired: options.certExpired,
        floodProtection: options.unflood
      };
      if (!options.nickpass) {
        client_options['channels'] = options.rooms;
      }
      this.robot.name = options.nick;
      bot = new Irc.Client(options.server, options.nick, client_options);
      next_id = 1;
      user_id = {};
      if (options.nickpass != null) {
        identify_args = "";
        if (options.nickusername != null) {
          identify_args += "" + options.nickusername + " ";
        }
        identify_args += "" + options.nickpass;
        bot.addListener('notice', function(from, to, text) {
          var room, _i, _len, _ref1, _results;
          if (from === 'NickServ' && text.toLowerCase().indexOf('identify') !== -1) {
            return bot.say('NickServ', "identify " + identify_args);
          } else if (options.nickpass && from === 'NickServ' && (text.indexOf('Password accepted') !== -1 || text.indexOf('identified') !== -1)) {
            _ref1 = options.rooms;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              room = _ref1[_i];
              _results.push(this.join(room));
            }
            return _results;
          }
        });
      }
      if (options.connectCommand != null) {
        bot.addListener('registered', function(message) {
          var strings;
          strings = options.connectCommand.split(" ");
          return self.command.apply(self, [strings.shift()].concat(__slice.call(strings)));
        });
      }
      bot.addListener('names', function(channel, nicks) {
        var nick, _results;
        _results = [];
        for (nick in nicks) {
          _results.push(self.createUser(channel, nick));
        }
        return _results;
      });
      bot.addListener('message', function(from, to, message) {
        var user;
        if (options.nick.toLowerCase() === to.toLowerCase()) {
          return;
        }
        console.log("From " + from + " to " + to + ": " + message);
        user = self.createUser(to, from);
        if (user.room) {
          console.log("" + to + " <" + from + "> " + message);
        } else {
          if (message.indexOf(to) !== 0) {
            message = "" + to + ": " + message;
          }
          console.log("msg <" + from + "> " + message);
        }
        return self.receive(new TextMessage(user, message));
      });
      bot.addListener('error', function(message) {
        return console.error('ERROR: %s: %s', message.command, message.args.join(' '));
      });
      bot.addListener('pm', function(nick, message) {
        var nameLength;
        console.log('Got private message from %s: %s', nick, message);
        if (process.env.HUBOT_IRC_PRIVATE) {
          return;
        }
        nameLength = options.nick.length;
        if (message.slice(0, nameLength).toLowerCase() !== options.nick.toLowerCase()) {
          message = "" + options.nick + " " + message;
        }
        return self.receive(new TextMessage({
          reply_to: nick,
          name: nick
        }, message));
      });
      bot.addListener('join', function(channel, who) {
        var user;
        console.log('%s has joined %s', who, channel);
        user = self.createUser(channel, who);
        return self.receive(new EnterMessage(user));
      });
      bot.addListener('part', function(channel, who, reason) {
        var user;
        console.log('%s has left %s: %s', who, channel, reason);
        user = self.createUser('', who);
        return self.receive(new LeaveMessage(user));
      });
      bot.addListener('kick', function(channel, who, _by, reason) {
        return console.log('%s was kicked from %s by %s: %s', who, channel, _by, reason);
      });
      bot.addListener('invite', function(channel, from) {
        console.log('%s invite you to join %s', from, channel);
        if (!process.env.HUBOT_IRC_PRIVATE) {
          return bot.join(channel);
        }
      });
      this.bot = bot;
      return self.emit("connected");
    };

    IrcBot.prototype._getTargetFromEnvelope = function(envelope) {
      var room, target, user;
      user = null;
      room = null;
      target = null;
      if (envelope.reply_to) {
        user = envelope;
      } else {
        user = envelope.user;
        room = envelope.room;
      }
      if (user) {
        if (user.room) {
          target = user.room;
        } else if (user.name) {
          target = user.name;
        } else if (user.reply_to) {
          target = user.reply_to;
        } else if ((typeof user.search === "function" ? user.search(/@/) : void 0) !== -1) {
          target = user;
        }
      } else if (room) {
        target = room;
      }
      return target;
    };

    return IrcBot;

  })(Adapter);

  exports.use = function(robot) {
    return new IrcBot(robot);
  };

}).call(this);
